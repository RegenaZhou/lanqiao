/*
问题描述
新年倒计时进入最后 10 秒，广场中心的彩灯线上挂着三盏红灯笼，从左到右分别位于整数位置 X,Y,Z。

灯笼所在的位置可以看作一条无限长的直线，线上有无数个挂点，每个挂点都用一个整数编号表示（即所有整数点都可以挂灯笼）。

小蓝要对这三盏灯笼进行一系列“移动”，每次移动须遵循：

从当前三盏灯笼中选出最左边或最右边的那一盏；
将选中的灯笼移动到另外两盏之间的某个整数坐标，且该坐标必须严格介于它们之间，不能与已有灯笼重合。
当无论取左端灯笼还是右端灯笼，都无法找到可插入的整数位置时，移动将终止。

小蓝希望通过每一步都作出最优选择，使得移动次数达到最多。现在，请你计算，在最优策略下，他最多能进行多少次移动。

输入格式
第一行包含一个整数 T（1≤T≤10^3），表示测试数据的组数。

接下来 T 行，每行包含三个整数 X,Y,Z（1≤X<Y<Z≤10^9），表示灯笼初始位置。

输出格式
输出 T 行，每行一个整数，表示在最优策略下可进行的最大移动次数。

样例输入
2
1 2 3
1 2 4

样例输出
0
1*/
#include <iostream>
#include <algorithm>
using namespace std;
using ll = long long;
void solve()
{
    ll arr[3] = { 0 }, ans = 0;
    cin >> arr[0] >> arr[1] >> arr[2];
    sort(arr, arr + 3);
    ll d1, d2;
    d1 = arr[1] - arr[0], d2 = arr[2] - arr[1];
    ans = max(d1, d2) - 1;
    cout << ans << '\n';
}
int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int t;
    cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}