/*
问题描述
小蓝深夜敲代码，一不小心，穿越到了“代码纪元”，一个虚拟的世界。

在这个世界里，每个人都有一个字符串代号。

为了防止身份混淆与冒用，这个世界的人们制定一条“镜像校验”规则：

一个人的身份将同时绑定其代号字符串 S 和其翻转后的字符串 S′。
例如，如果小蓝的代号为 abac，那么代号 caba 也会被视为与他关联。

现在，小蓝已经有了一个代号 S，但他发现这个代号存在被破解的风险。他决定立刻注册一个新代号 T。
根据规定，新代号 T 必须在字典序上严格大于他当前绑定的所有身份标识。
也就是说，T 必须同时满足以下两个条件：

在字典序上，T 必须严格大于 S。
在字典序上，T 必须严格大于 S 的翻转字符串 S′。
为了能尽快抢注到新的身份，小蓝希望找到满足上述条件的、字典序最小的那个新代号 T。

作为他的技术顾问，请你编写一个程序，帮助小蓝计算出这个理想的新代号。

字典序的比较规则类似于字典中单词的排序：从左到右逐位比较，如果对应位置的字符不同，
则较小的字符对应的字符串字典序较小；如果所有对应位置的字符都相同，则两个字符串字典序相同。

输入格式
输入只有一行，包含一个仅由小写字母（a∼z）组成的字符串S。

数据保证 1≤∣S∣≤10^5，其中∣S∣ 代表字符串 S 的长度。

输出格式
输出一行，包含一个字符串 T，表示符合条件的、字典序最小的新代号。

样例输入
zaz

样例输出
zaza*/
#include <iostream>
#include <string>
using namespace std;
int main()
{
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	string s1, s2;
	cin >> s1;
	s2 = s1;
	reverse(s2.begin(), s2.end());
	if (s1 > s2) cout << s1 << "a\n";
	else cout << s2 << "a\n";
	return 0;
}