/*
问题描述
琥珀纪 2157 年，星核猎手银狼在一次任务中，成功入侵了星际和平公司的一座秘密数据金库。金库的核心防御由一串冗长的加密忆泡序列 S 构成，其长度为 4 的倍数。

经过初步解析，银狼发现这种加密协议相当古老：所有忆泡根据其在序列中的位置，被分配到了四条独立的「以太信道」上。她可以启动“小助手”程序，对序列进行重组，具体如下：

选择序列中任意一个位置 i（1≤i≤4N−4），交换第 i 号忆泡与第 i+4 号忆泡的内容。此操作可以进行任意多次。
银狼的情报指出，解开金库的“钥匙”并非某个单一的密码，而是隐藏在序列中的特定代码。当连续的四个忆泡恰好构成 blue 这一序列时，便意味着成功拼凑出了一把完整的“秘钥”。每一把秘钥都能解开金库中的一份档案。

现在请你帮助银狼计算，他最多能从初始的加密忆泡序列 S 中，拼凑出多少把 blue 秘钥？

输入格式
输入一行，为一个仅由小写英文字母组成的字符串S。（4≤∣S∣≤200000，∣S∣ 表示字符串 S 的长度，且 ∣S∣ 是 4 的倍数）

输出格式
输出一行，为一个整数，代表能拼凑出的 blue 秘钥的最大数量。

样例输入
blueblue

样例输出

2*/
#include <bits/stdc++.h>
using namespace std;
int a[4][4]={0};
vector<int> ans(4,1e5);
int main()
{
  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
  string s;
  int sum=0;
  cin>>s;
  for(int i=0;i<(int)s.size();i++)
  {
    int num=i%4;
    if(s[i]=='b') a[num][0]++;
    else if(s[i]=='l') a[num][1]++;
    else if(s[i]=='u') a[num][2]++;
    else if(s[i]=='e') a[num][3]++;
  }
  for(int i=0;i<4;i++)
  {
    ans[i]=min({a[0][i%4],a[1][(i+1)%4],a[2][(i+2)%4],a[3][(i+3)%4]});
    sum+=ans[i];
  }
  if(sum*4==s.size() && sum!=ans[0]) sum--;
  cout<<sum<<'\n';
  return 0;
}
