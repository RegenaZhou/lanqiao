/*
问题描述
小蓝正在努力成为一名航空员，这需要他锻炼出足够的反应力。

他来到一台用来训练反应力的机器前，训练的规则如下：小蓝可以选择在 N 个时间节点进行攻击。
在某个时间节点 X 攻击机器后，机器将在 X+D 节点反击小蓝。此时，小蓝需要躲避，如果被机器击中，任务将失败。

小蓝无法在同一时间节点同时进行攻击和躲避。他想知道，在确保任务成功的前提下，自己最多能攻击机器多少次。

输入格式
第一行包含两个整数 N,D(1,≤N≤10^5 ,1≤D≤10^9 )，分别表示时间节点的数量和机器反击的延迟。

第二行包含 N 个整数Ai(1≤A1<A2<A3<⋯<AN≤10^9)，表示时间节点的具体值。

输出格式
输出一个整数，表示小蓝在确保任务成功的前提下，最多能攻击机器的次数。

样例输入
5 2
1 3 4 6 8

样例输出
3

说明
在样例中，小蓝可以在时间节点 1、4 和 8 进行攻击。具体步骤如下：

在时间节点 1 攻击，机器将在时间节点 3 反击，小蓝可以躲避。
在时间节点 4 攻击，机器将在时间节点 6 反击，小蓝可以躲避。
在时间节点 8 攻击，机器将在时间节点 10 反击，小蓝可以躲避。
因此，小蓝最多可以攻击机器 3 次。*/
#include <iostream>
using namespace std;
using ll = long long;
const int N = 1e5 + 9;
map<ll, int> mp;
ll a[N];
int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int n;
    cin >> n;
    ll d;
    cin >> d;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        mp[a[i]] = 1;
    }
    ll sz = 0;
    for (int i = 1; i <= n; i++)
    {
        if (mp[a[i]] == 1)
        {
            sz++;
            mp[a[i] + d] = 0;
        }
    }
    cout << sz << '\n';
    return 0;
}