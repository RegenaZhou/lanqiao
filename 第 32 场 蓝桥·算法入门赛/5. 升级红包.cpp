/*
问题描述
双 11 的红包雨倾盆而下，小蓝手指飞快地在手机屏幕上滑动，瞬间抢到一个价值 X 元的平台红包。兴奋之余，他注意到平台的特殊规则：

每个红包金额 N 都可以拆分成两个正整数 A 和 B（需满足 A+B=N），然后平台会偷偷地将原红包替换为价值 A×B 元的“升级红包”。
小蓝可以对当前红包重复这个操作任意次，甚至一次都不做。现在，他想知道，能否通过这些操作将初始 X 元红包变成目标的 Y 元。
作为小蓝的算法助手，请你帮他判断这个可能性。

输入格式
第一行包含一个整数 T（1≤T≤10^3），表示测试数据的组数。

接下来 T 行，每行包含两个正整数 X 和 Y（1≤X,Y≤10^9）。

输出格式
输出 T 行，对于每个测试用例，输出 YES（如果可能）或 NO（如果不可能）。*/
#include <iostream>
using namespace std;
void solve()
{
    int x, y;
    cin >> x >> y;
    if (x >= 5) cout << "YES\n";
    else
    {
        cout << (y <= x ? "YES\n" : "NO\n");
    }
}
int main()
{
    int t;
    cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}